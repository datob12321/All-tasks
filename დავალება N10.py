# Heap sort
# სორტირების ამ ალგორითმს საფუძვლად უდევს binary tree სტრუქტურა, რომელიც მოიაზრებს
# მონაცემების(რიცხვების) გადანაწილებას ერთი ფუძიდან ორ შტოზე. ეს პროცესი გრძელდება
# მანამ, სანამ არ ამოგვეწურება ელემენტების რაოდენობა. თუ ამ ელემენტებს გადავნომრავთ, მაშინ
# მივიღებთ, რომ თითოეული ფუძის(მშობლის) ინდექსისთვის (მაგ:i), ერთი(მარცხენა) შვილის
# (შტოს) ინდექსი იქნება i*2+1, ხოლო მარჯვენასი-i*2+2. საპირისპირო შემთხვევის ფორმულა კი
# იქნება (i-1)//2. უნდა აღინიშნოს, რომ მშობელი შტოს მაქსიმალური ინდექსი იქნება
# ელემენტების რაოდენობას გამოკლებული ერთი გაყოფილი ორზე დამრგვალებით, (n-1)//2.
# თუ განვიხილავთ მასივის ჭრილში მოცემულ კანონზომიერებას, მაშინ ვიტყვით, რომ მასივის
# ელემენტებმა (n-1)//2 ინდექსამდე უნდა გადაამოწმონ, არიან თუ არა მეტი მათ რომელიმე
# (მარცხენა ან მარჯვენა)შვილზე. თუ ასეა, არაფერი იცვლება, თუ არა და ის ადგილს უცვლის
# შვილებიდან უდიდესს.  ამის მიღწევა შეგვიძლია რაიმე ფუნქციის შექმნით. ეს პროცესი
# მოცემული ელემენტისთვის გრძელდება მანამ, სანამ შტოები აქვს. როცააღარ დარჩება მის
# ქვემოთ შტოები ან შტო, ცხადია ვერაფერს ვერ შეუცვლის ადგილს. ასეთი შემთხვევებისთვის
# კი ფუნქციის რეკრუცია გამოგვადგება. ე.ი. მასივის კონკრეტული წევრისთვის მანამდე
# შესრულდება მოცემული ფუნქცია, სანამ შტოები არ გამოელევა. როცა ლუპი გადაუვლის ყველა
# ელემენტს, ამ დროს უკვე ხის ფუძე, ანუ მასივის პირველი წევრი მიიღებს უდიდეს
# მნიშვნელობას და ყველა მშბელი შტო მეტი იქნება საკუთარ შვილ შტოებზე. ანუ ყოველი
# arr[i]>arr[i*2+1] && arr[i]>arr[i*2+2]. რა თქმა უნდა, i<arr[(n-1)//2].


def heapify(arr, length, index):

    # პირველ რიგში ცვლად largest-ს მივანიჭებთ index პარამეტრის მნიშვნელობას. თუ
    # რომელიმე შტო-left ან right მეტი აღმოჩნდა index-ზე, მაშინ ის ხდება უდიდესი.

    largest = index
    left = 2*index + 1
    right = 2*index + 2

    # მოწმდება left და right სცდება თუ არა  მასივის სიგრძეს და arr მასივის left ან right
    # ინდექსის ელემენტი arr[left] ან arr[right] მეტია arr[index]-ზე თუ არა.

    if left < length and arr[left] > arr[index]:
        largest = left

    # ამჯერად right შედარდება არა arr[index]-თან, არამედ arr[largest]-თან. ამ გზით
    # შევძლებთ გავარკვიოთ left და right-ს შორის უდიდესი, რადგან პირველი if-ის შემდეგ
    # შესაძლოა largest-ს left-ის მნიშვნელობა მიენიჭოს.

    if right < length and arr[right] > arr[largest]:
        largest = right

    # თუ largest-მა შემოწმების შემდეგ მნიშვნელობა შეიცვალა, მაშინ უნდა გადავანაცვლოთ
    # შესაბამისი ელემენტები.

    if largest != index:
        arr[index], arr[largest] = arr[largest], arr[index]

        # გამოვიყენებთ რეკრუციას, რათა თუ მშობელი შტო შეიცვლის ინდექსს, იგი შედარდეს
        # ჩამნაცვლებელი შტოს შვილ შტოს(შვილიშვილს).

        heapify(arr, length, largest)

        # წინა ხაზში heapify ფუნქციას რეკრუციაში გადაეცემა პარამეტრად ქვემოთ ჩამოსული
        # ელემენტის ახალი  ინდექსი.

# ზედა ფუნქცია წარმოადგენს ჩვენი ალგორითმის პირველ ნაწილს. ახლა საჭიროა შევქმნათ
# მთავარი ფუნქცია, რომელსაც პარამეტრად მასივი გადაეცემა.

def heap_sort(arr):

    length = len(arr)

    # სიგრძის ნახევრიდან პირველი ინდექსის ჩათვლით ვიძახებთ heapify ფუნქციას. ე.ი.
    # ყველა მშობელი შტო მის შვილებზე მეტი იქნება:arr[i]>arr[2*i+(1 ან 2)].

    for i in range(length//2, -1, -1):
        heapify(arr, length, i)

    # ახლა საჭიროა, თავში, ზემოთ მყოფმა ელემენტმა, arr[0]_მა ადგილი გაუცვლოს ბოლო
    # პოზიციაზე arr[length-1] მყოფ ელემენტს. ასეთ დროს მასივის მაქსიმალური ელემენტი
    # ბოლო პოზიციაზე მოხვდება. საინტერესოა რა ბედი ელის ხის თავში მოხვედრილ წევრს.
    # მან უნდა დაადგინოს არის თუ არა მეტი ქვედა შტოებზე. ამიტომ უნდა გამოვიძახოთ
    # heapify ფუნქცია, რომელიც ნაცნობი კანონზომიერებით დაალაგებს ელემენტებს. ვინაიდან
    # ბოლო პოზიციაზე სასურველი შედეგი მივიღეთ, შეგვიძლია ის გადავაგდოთ. ორობით ხის
    # მაგალითზე შეგვიძლია ქვედა მარჯვენა ტოტი, შტო მოვჭრათ, მასივების შემთხვევაში კი
    # heapify ფუნქციის  ყოველი გამოძახებისას ერთით უნდა შევამციროთ length პარამეტრის
    # ზომა. ამიტომაც მას აღარ გადავცემთ არგუმენტად მასივის სიგრძეს-length = len(arr),
    # არამედ for ლუპის ცვლადს, რომელიც ერთით მცირდება ყოველი გამეორებისას. # მესამე
    # არგუმენტი კი იქნება 0, რადგან სხვა დანარჩენი ინდექსისთვის ისედაც შესრულებულია
    # heapify ფუნქცია.

    for i in range(length-1, 0, -1):

        # თითეულ გამეორებაზე arr[0] ანუ უდიდესი ელემენტი ადგილს უცვლის ბოლო ელემენტს

        arr[i], arr[0] = arr[0], arr[i]

        # გაცვლის შემდეგ კი ერთით მცირდება heapify ფუნქციის length პარამეტრის სიგრძე და
        # სიის პირველი ,ე.ი. ხის ზედა ელემენტისთვის, სრულდება heapify ფუნქცია. for
        # ლუპის დასრულების შემდეგ მივიღებთ დალაგებულ სიას.

        heapify(arr, i, 0)

    return arr


from random import randint

def random_num_list(min=1, max=100, length=20):
    rand_array = []
    for i in range(0, length):
        rand_array.append(randint(min, max))
    return rand_array

my_array = random_num_list(1, 250, 15)
sorted_array = heap_sort(my_array)
# print(sorted_array)
